# Copyright 2021, Peter Birch, mailto:peter@lightlogic.co.uk
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
from operator import sub

# Main sections
DESIGN_CONFIG  = "configuration"
DESIGN_NODES   = "nodes"
DESIGN_REPORTS = "reports"
# Mesh configuration
CONFIG_ROWS    = "rows"
CONFIG_COLUMNS = "columns"
CONFIG_NODE    = "node"
CFG_ND_INPUTS  = "inputs"
CFG_ND_OUTPUTS = "outputs"
CFG_ND_REGS    = "registers"
CFG_ND_SLOTS   = "slots"
# Per-node configuration
NODE_ROW    = "row"
NODE_COLUMN = "column"
NODE_INSTRS = "instructions"
NODE_MSGS   = "messages"
# Design reports
DSG_REP_STATE   = "state"
DSG_REP_OUTPUTS = "outputs"

def export(
    output_path,
    mesh_rows, mesh_columns,
    node_inputs, node_outputs, node_registers, node_slots,
    instructions, messages, state_map, output_map,
):
    """
    Export the compiled design to a file for loading into the architectural
    model or the RTL design.

    Args:
        output_path   : Path to the output file to write
        mesh_rows     : Number of rows in the mesh
        mesh_columns  : Number of columns in the mesh
        node_inputs   : Number of inputs per node
        node_outputs  : Number of outputs per node
        node_registers: Number of working registers per node
        node_slots    : Number of instruction slots per node
        instructions  : Instruction sequences for every node
        messages      : Every message generated by every node
        state_map     : Mapping of where each flop is held in the mesh
        output_map    : Mapping of where each output is driven from in the mesh
    """
    # Assemble the model
    model = {
        DESIGN_CONFIG: {
            CONFIG_ROWS   : mesh_rows,
            CONFIG_COLUMNS: mesh_columns,
            CONFIG_NODE   : {
                CFG_ND_INPUTS : node_inputs,
                CFG_ND_OUTPUTS: node_outputs,
                CFG_ND_REGS   : node_registers,
                CFG_ND_SLOTS  : node_slots,
            },
        },
        DESIGN_NODES  : [],
        DESIGN_REPORTS: {},
    }

    # Build up per-node information
    for (row, col), instrs in instructions.items():
        # Start building up a node description
        node = {
            NODE_ROW   : row,
            NODE_COLUMN: col,
            NODE_INSTRS: instrs,
            NODE_MSGS  : messages.get((row, col), []),
        }
        # Append node into the model
        model[DESIGN_NODES].append(node)

    # Insert the state mapping
    model[DESIGN_REPORTS][DSG_REP_STATE] = (state_report := {})
    for (row, col, idx), flop in state_map.items():
        state_report[f"R{row}C{col}I{idx}"] = str(flop.output[0])

    # Insert the output mapping
    model[DESIGN_REPORTS][DSG_REP_OUTPUTS] = output_map

    # Write the model to file
    with open(output_path, "w") as fh:
        json.dump(model, fh, indent=4)
